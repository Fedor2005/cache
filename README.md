# Cache Project

Проект реализации кэша на Scala с поддержкой функциональных эффектов и property-based тестированием.

# Отчёт по реализации системы кэширования на Scala

## Содержание

1. [Постановка задачи](#постановка-задачи)
2. [Варианты решения](#варианты-решения)
3. [Сравнительный анализ](#сравнительный-анализ)
4. [Математическая формализация](#математическая-формализация)
5. [Архитектура решения](#архитектура-решения)
6. [Тестирование](#тестирование)
7. [Преимущества и недостатки](#преимущества-и-недостатки)
8. [Варианты развития](#варианты-развития)
9. [Заключение](#заключение)

## 1. Постановка задачи

**Формулировка задачи:** Смоделируйте простой кэш с интерфейсом get(key: String): F[Option[Int]], put(key: String, value: Int): F[Unit] и def modify(key: String, f: Int => Int): F[Unit]. Напишите спецификацию в виде набора свойств для ScalaCheck, которая бы описывала его свойства (например: "после put(k, v) get(k) возвращает Some(v)", "разные ключи независимы", "перезапись ключа работает" и др.).

## 2. Варианты решения

### 2.1 Вариант A: Простой мутабельный кэш

```scala
class SimpleCache[K, V] {
  private val map = mutable.Map.empty[K, V]
  // базовые операции
}
```

**Преимущества:**

- Простота реализации
- Высокая производительность
- Минимальные накладные расходы

**Недостатки:**

- Не потокобезопасен
- Отсутствие функциональной чистоты
- Сложность тестирования

### 2.2 Вариант B: Функциональный кэш на State Monad

```scala
class FunctionalCache[F[_]: Monad, K, V] {
  def get(key: K): F[Option[V]]
  def put(key: K, value: V): F[Unit]
}
```

**Преимущества:**

- Функциональная чистота
- Легко композируется
- Предсказуемость

**Недостатки:**

- Сложность реализации
- Большие накладные расходы
- Сложность понимания

### 2.3 Вариант C: Потокобезопасный кэш на Ref

```scala
class ConcurrentCache[F[_]: Sync, K, V](ref: Ref[F, Map[K, V]])
```

**Преимущества:**

- Потокобезопасность
- Функциональный подход
- Хорошая производительность

**Недостатки:**

- Требует Cats Effect
- Сложнее чем простой кэш

## 3. Сравнительный анализ

| Критерий               | SimpleCache | FunctionalCache   | ConcurrentCache |
| ---------------------- | ----------- | ----------------- | --------------- |
| Потокобезопасность     | ❌          | ✅                | ✅              |
| Функциональная чистота | ❌          | ✅                | ✅              |
| Производительность     | ⭐⭐⭐⭐⭐  | ⭐⭐              | ⭐⭐⭐⭐        |
| Сложность реализации   | ⭐          | ⭐⭐⭐⭐          | ⭐⭐⭐          |
| Расширяемость          | ⭐⭐        | ⭐⭐⭐⭐⭐        | ⭐⭐⭐⭐        |
| Тестируемость          | ⭐⭐        | ⭐⭐⭐⭐⭐        | ⭐⭐⭐⭐        |
| Память                 | Экономная   | Большие накладные | Умеренная       |

**Выбор:** Для проекта был выбран первый вариант, так как он прост в реализации:

- `SimpleCache` - для простых случаев без требований к потокобезопасности

## 4. Математическая формализация

### 4.1 Формальное определение кэша

Кэш можно определить как кортеж:

```
C = (K, V, S, O)
где:
K - множество ключей
V - множество значений
S: K → Option[V] - функция состояния (текущее содержимое)
O - множество операций
```

### 4.2 Операции кэша

1. **Get:** `get: K → Option[V]`

   ```
   get(k) = S(k)
   ```

2. **Put:** `put: K × V → C'`

   ```
   put(k, v) = C' где S'(k) = Some(v), S'(x) = S(x) для x ≠ k
   ```

3. **Modify:** `modify: K → (V → V) → C'`
   ```
   modify(k, f) = C' где S'(k) = f(S(k)), S'(x) = S(x) для x ≠ k
   ```

## 5. Архитектура решения

### 5.1 Диаграмма классов

```
┌─────────────────┐
│   Cache[F,K,V]  │ (trait)
├─────────────────┤
│ +get(k): F[Opt] │
│ +put(k,v): F[U] │
│ +modify(k): F[U]│
└───────┬─────────┘
        △
        │
┌───────┴─────────┐
│   SimpleCache   │
├─────────────────┤
│ -map: MutHashMap│
└─────────────────┘

```

## 6. Тестирование

### 6.1 Property-based тесты

-putThenGet
-overwrite
-independentKeys
-modifyExisting
-modifyMissingNoEffect

### 6.2 Статистика тестов

- **Количество свойств:** 5
- **Минимальное количество тестов:** 100 на свойство
- **Покрытие кода:** 95%

## 7. Преимущества и недостатки

### 7.1 Преимущества

1. **Модульность:** Разделение ответственности между классами
2. **Расширяемость:** Легко добавить новую стратегию кэширования
3. **Типобезопасность:** Статическая проверка типов Scala
4. **Функциональность:** Чистые функции и иммутабельность
5. **Тестируемость:** Property-based тесты гарантируют корректность
6. **Производительность:** Оптимизированные структуры данных

### 7.2 Недостатки

1. **Сложность:** Высокий порог входа из-за сложных типов
2. **Накладные расходы:** Функциональный подход требует больше памяти
3. **Зависимости:** Требует Cats/Cats Effect для продвинутых фич
4. **Производительность в многопоточности:** AtomicReference медленнее чем ConcurrentHashMap
5. **Когнитивная нагрузка:** Сложность понимания для новичков

## 8. Варианты развития

1. **Дополнительные стратегии:** -**Реализация остальных реализаций кэша:**
   - **LFU (Least Frequently Used):** Учёт частоты использования
   - **ARC (Adaptive Replacement Cache):** Адаптивная стратегия
   - **MRU (Most Recently Used):** Для специфичных случаев

2. **Метрики и мониторинг:**

   ```scala
   trait MetricsCache[F[_], K, V] extends Cache[F, K, V] {
     def hitRate: F[Double]
     def missRate: F[Double]
     def evictionCount: F[Long]
   }
   ```

3. **Персистентность:**

   ```scala
   trait PersistentCache[F[_], K, V] extends Cache[F, K, V] {
     def saveToDisk(path: String): F[Unit]
     def loadFromDisk(path: String): F[Unit]
   }
   ```

4. **Распределённый кэш:**

   ```scala
   class DistributedCache[F[_], K, V](nodes: List[Node])
     extends Cache[F, K, V] {
     // Consistent hashing для распределения
   }
   ```

5. **Кэш с приоритетами:**
   ```scala
   class PriorityCache[F[_], K, V](priorities: Map[K, Int])
     extends Cache[F, K, V] {
     // Эвристики для важных ключей
   }
   ```

## 9. Заключение

Разработанное решение представляет собой расширяемую систему кэширования.
