# Cache Project

Проект реализации кэша на Scala с поддержкой функциональных эффектов и property-based тестированием.

# Отчёт по реализации системы кэширования на Scala

## 1. Постановка задачи

**Формулировка задачи:** Смоделируйте простой кэш с интерфейсом get(key: String): F[Option[Int]], put(key: String, value: Int): F[Unit] и def modify(key: String, f: Int => Int): F[Unit]. Напишите спецификацию в виде набора свойств для ScalaCheck, которая бы описывала его свойства (например: "после put(k, v) get(k) возвращает Some(v)", "разные ключи независимы", "перезапись ключа работает" и др.).

## 2. Формализация задачи

Пусть:

- **K** - множество ключей (String)
- **V** - множество значений (Int)
- **Cache** - частичная функция: K → V
- **C** ⊆ K × V - текущее состояние кэша (множество пар ключ-значение)

Операции:
**get(k)**: C → Option[V]

- Если ∃v: (k, v) ∈ C, то возвращает Some(v)
- Иначе возвращает None

**put(k, v)**: C → C' = (C \ {(k, \_)}) ∪ {(k, v)}

**modify(k, f)**: C → C' =

- Если ∃v: (k, v) ∈ C, то C' = (C \ {(k, v)}) ∪ {(k, f(v))}
- Иначе C' = C (операция не изменяет кэш)

Необходимо реализовать:
Кэш с интерфейсом:

```scala
trait Cache[F[_]] {
  def get(key: String): F[Option[Int]]
  def put(key: String, value: Int): F[Unit]
  def modify(key: String, f: Int => Int): F[Unit]
}
```

Свойства для ScalaCheck, проверяющие корректность реализации

## 3. Вариант решения

```scala
class SimpleCache extends Cache[Id, String, Int]:
  private val map = Map[String, Int]
```

Данная реализация представляет собой пройстейшую модель кэша.
Контейнер Map[String, Int] это мутабельная хеш-таблица.
Id[A] = A - тождественный эффект

## 4. Математические инварианты

Доказанные свойства (инварианты):

1. **Сохранение значения**:
   -putThenGet

   ```
   ∀k∀v: put(k, v) >> get(k) = Some(v)
   ```

2. **Перезапись по ключу**
   -overWrite

```
 ∀k∀v1∀v2: put(k, v1) >> put(k, v2) >> ≡ put(k, v2)
```

3. **Независимость ключей**:
   -independentKeys

   ```
   ∀k₁∀k₂∀v: (k₁ ≠ k₂) ∧ put(k₁, v) ⇒ get(k₂) = None ∨ предыдущее_значение(k₂)
   ```

4. **Идемпотентность put**:
   -idempotencePut

   ```
   ∀k∀v: put(k, v) >> put(k, v) ≡ put(k, v)
   ```

5. **Модификация значения**
   -modifyExisting

```
 ∀k∀v∀f: put(k, v) >> modify(k, f) => get(k) = Some(f(v))
```

6. **Модификация по несуществующему ключу**
   -modifyMissingNoEffect

```
 ∀k∀v∀f: modify(k, f) => get(k) = None
```

7. **Композиция modify**:
   -composingModify
   ```
   ∀k∀v∀f∀g: put(k, v) >> modify(k, f) >> modify(k, g) ≡ put(k, g(f(v)))
   ```

## 5. Возможные варианты развития

-Шаблонная реализация для различных типов Key и Value.
-Кэш с ограничением
-Time-To-Live cache: каждая запись хранится ограниченное время

## 6. Заключение

Реализованное решение представляет собой простой, но полный кэш с корректной спецификацией свойств. Математическая формализация точно определяет ожидаемое поведение и ключевые инварианты системы.

Данная работа может служить основой для более сложных систем кэширования и является хорошим примером property-based testing в Scala.
